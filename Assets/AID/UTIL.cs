using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.EventSystems;

//TODO inst and parent and set local pos n rot


namespace AID
{
    static public partial class UTIL
    {
        static private GameObject autoGeneratedGameRules;
        static private string autoGenGameRulesName = "AUTO_GEN_GAME_RULES";

        


        //auto generated Game Rules is a special game object that tends to auto generated required singletons that are also monobehaviours
        static public GameObject GetAutoGameRules()
        {
            if (autoGeneratedGameRules != null)
                return autoGeneratedGameRules;

            autoGeneratedGameRules = GameObject.Find(autoGenGameRulesName);

            if (autoGeneratedGameRules == null)
            {
                autoGeneratedGameRules = new GameObject(autoGenGameRulesName);
            }

            UnityEngine.Object.DontDestroyOnLoad(autoGeneratedGameRules);

            return autoGeneratedGameRules;
        }

        static public GameObject InstantiateAndParent(Transform parent, GameObject prefab, Vector3 pos, Quaternion rot)
        {
            GameObject ret = GameObject.Instantiate<GameObject>(prefab);
            ret.transform.parent = parent;
            ret.transform.localPosition = pos;
            ret.transform.localRotation = rot;

            return ret;
        }

        static public GameObject InstantiateAndParent(Transform parent, GameObject prefab)
        {
            return InstantiateAndParent(parent, prefab, Vector3.zero, Quaternion.identity);
        }

        static public void ShuffleArray<T>(T[] arr)
        {
            for (int i = 0; i < arr.Length; i++)
            {
                int index = Random.Range(0, arr.Length - 1);
                T tmp = arr[i];
                arr[i] = arr[index];
                arr[index] = tmp;
            }
        }

        static public void Shuffle<T>(List<T> list)
        {
            for (int i = 0; i < list.Count; i++)
            {
                int index = Random.Range(0, list.Count - 1);
                T tmp = list[i];
                list[i] = list[index];
                list[index] = tmp;
            }
        }


        //ReadAllText variant that if the file doesn't exist, creates and new one
        static public string ReadAllText(string loc)
        {
#if !UNITY_WEBPLAYER
            if (File.Exists(loc))
                return File.ReadAllText(loc);
            else
                File.Create(loc);
#else
		Debug.LogError("Cannot read file in web player");
#endif
            return "";
        }

        static public void WriteAllText(string loc, string data)
        {
#if !UNITY_WEBPLAYER
            Directory.CreateDirectory(Path.GetDirectoryName(loc));
            File.WriteAllText(loc, data);
#else
		Debug.LogError("Cannot write file in web player");
#endif
        }

        
        static public void FlipActivation(GameObject go)
        {
            if (go != null) go.SetActive(!go.activeInHierarchy);
        }
        //	
        //		static public void FlipEnable(Behaviour b)
        //		{
        //			if(b != null) b.enabled = !b.enabled;
        //		}

        static public bool HasWhitespace(string str)
        {
            Regex regEx = new Regex("\\s");
            Match match = regEx.Match(str);
            return match.Success;
        }



        static public float Angle2D(Vector3 dir)
        {
            return (Mathf.Rad2Deg * Mathf.Atan2(dir.y, dir.x) + 270) % 360;
        }

        //does rotation of euler angles based on xy plane only
        static public void LookAt2D(Transform trans, Vector3 lookAtPos)
        {
            float atanOut = Angle2D(lookAtPos - trans.position);
            //atan requires a *-1 to put it in same space as transform euler
            Vector3 curEuler = trans.rotation.eulerAngles;
            trans.rotation = Quaternion.Euler(curEuler.x, curEuler.y, atanOut);
        }

        //does rotation of euler angles based on xy plane only
        static public void LookAt2D(Transform trans, Vector3 lookAtPos, float maxDegrees)
        {
            float curAtan = Angle2D(trans.up);
            float atanOut = Angle2D(lookAtPos - trans.position);

            Vector3 curEuler = trans.rotation.eulerAngles;
            trans.rotation = Quaternion.Euler(curEuler.x, curEuler.y, Mathf.MoveTowardsAngle(curAtan, atanOut, maxDegrees));
        }

        //does rotation of euler angles based on xy plane only, optimised ver, takes cur angle and returns new
        static public float LookAt2D(Transform trans, Vector3 lookAtPos, float maxDegrees, float curAtan)
        {
            //float curAtan = Angle2d(trans.up);
            float atanOut = Angle2D(lookAtPos - trans.position);
            atanOut = Mathf.MoveTowardsAngle(curAtan, atanOut, maxDegrees);

            Vector3 curEuler = trans.rotation.eulerAngles;
            trans.rotation = Quaternion.Euler(curEuler.x, curEuler.y, atanOut);
            return atanOut;
        }

        //moves a file from resrouces to persist storage if it doesn't exist there
        static public bool EnsureTextResourceIsHere(string fileAndFullPath, string nameInResources)
        {
            TextAsset textResource = Resources.Load<TextAsset>(nameInResources);

            if (!File.Exists(fileAndFullPath))
            {
                if (textResource == null)
                {
                    return false;
                }
                UTIL.WriteAllText(fileAndFullPath, textResource.text);
            }
            else if(textResource == null)
            {
                //so there is a file there but we have no idea what it is so nuke it
                File.Delete(fileAndFullPath);
                return false;
            }
            return true;    //if we get here it all went according to plan
        }

        //remove nulls from a collection
        static public List<T> RemoveNulls<T>(List<T> list)
        {
            return list.Where(x => x != null).ToList();
        }

        static public void FlipActivation<T>(T goa) where T : IEnumerable
        {
            foreach (GameObject go in goa)
                FlipActivation(go);
        }

        static public void ToggleActive<T>(T goa) where T : IEnumerable
        {
            FlipActivation(goa);
        }

        static public void SetActiveAll<T>(T goa, bool state) where T : IEnumerable
        {
            foreach (GameObject go in goa)
                if (go != null) go.SetActive(state);
        }

        static public void ActivateAll<T>(T goa) where T : IEnumerable
        {
            SetActiveAll(goa, true);
        }

        static public void DeactivateAll<T>(T goa) where T : IEnumerable
        {
            SetActiveAll(goa, false);
        }
        //		
        //		
        //		
        //		static public void FlipEnabled<T>(T boa) where T : IEnumerable
        //		{
        //			foreach(Behaviour b in boa)
        //				FlipEnable(b);
        //		}
        //		
        //		static public void ToggleEnabled<T>(T boa) where T : IEnumerable
        //		{
        //			FlipEnabled(boa);
        //		}
        //		
        //		static public void SetEnabledAll<T>(T boa, bool state) where T : IEnumerable
        //		{
        //			foreach(Behaviour b in boa)
        //				if(b != null) b.enabled = state;
        //		}
        //		
        //		static public void EnableAll<T>(T boa) where T : IEnumerable
        //		{
        //			SetEnabledAll(boa, true);
        //		}
        //		
        //		static public void DisableAll<T>(T boa) where T : IEnumerable
        //		{
        //			SetEnabledAll(boa, false);
        //		}
        //		



        static public void SendMessageToAll(GameObject[] gos, string msgName, SendMessageOptions opts)
        {
            //foreach(GameObject go in gos)
            for (int i = 0; i < gos.Length; i++)
                if (gos[i] != null) gos[i].SendMessage(msgName, opts);
        }

        static public void SendMessageToAll(List<GameObject> gos, string msgName, SendMessageOptions opts)
        {
            //foreach(GameObject go in gos)
            for (int i = 0; i < gos.Count; i++)
                if (gos[i] != null) gos[i].SendMessage(msgName, opts);
        }

        static public void SendMessageToAll(GameObject[] gos, string msgName, object param, SendMessageOptions opts)
        {
            for (int i = 0; i < gos.Length; i++)
                if (gos[i] != null) gos[i].SendMessage(msgName, param, opts);
        }

        static public void SendMessageToAll(List<GameObject> gos, string msgName, object param, SendMessageOptions opts)
        {
            for (int i = 0; i < gos.Count; i++)
                if (gos[i] != null) gos[i].SendMessage(msgName, param, opts);
        }

        static public bool CompareTagCollection(GameObject go, List<string> tags)
        {
            //foreach(string s in tags)
            for (int i = 0; i < tags.Count; i++)
            {
                if (go.CompareTag(tags[i]))
                    return true;
            }
            return false;
        }

        static public T RandomFrom<T>(T[] arr)
        {
            if (arr.Length == 0) return default(T);
            return arr[Random.Range(0, arr.Length)];
        }

        static public T RandomFrom<T>(List<T> list)
        {
            if (list.Count == 0) return default(T);
            return list[Random.Range(0, list.Count)];
        }

        
        

        /*
	    	Makes unity's perline 2d into a loopable 1d noise.
	    	How far through the loop
	    	How long is the loop
	    	what is the radius of the circle we are using in the 2d perlin field
	    	What is the offset from the origin of the perlin field
	    */
        static public float Perlin1DLoop(float t, float peroid, float radius, float offset)
        {
            float p = Mathf.Sign(t) * (Mathf.Abs(t) % radius);
            float x = Mathf.Sin(p / peroid * Mathf.PI * 2), y = Mathf.Cos(p / peroid * Mathf.PI * 2);
            return Mathf.PerlinNoise(x * radius, y * radius + offset);
        }

        static readonly float[] PRIMES = new float[] { 23, 29, 41, 53, 83, 89, 113, 131, 173, 179, 191 };

        /*
	    	Perlin with given octaves, produces more complex noise
	    */
        static public float Perlin2DLayered(float x, float y, int layers)
        {
            float retval = 0;
            float curScale = 1;
            const float ITER_SCALE = 0.4f;
            float curWindow = 0;
            float prime = 0;
            float basis = PRIMES[0];

            layers = Mathf.Clamp(layers, 1, PRIMES.Length);
            for (int i = 0; i < layers; i++)
            {
                prime = PRIMES[i];

                retval += Mathf.PerlinNoise(x * prime / basis, y * prime / basis) * curScale;
                curWindow += curScale;
                curScale *= ITER_SCALE;
            }

            return retval / curWindow;
        }

        /*
	    	Makes unity's perline 2d into a loopable 1d noise.
	    	How far through the loop
	    	How long is the loop
	    	what is the radius of the circle we are using in the 2d perlin field
	    	What is the offset from the origin of the perlin field
	    */
        static public float Perlin1DLayeredLoop(float t, float peroid, float radius, float offset, int layers)
        {
            float p = Mathf.Sign(t) * (Mathf.Abs(t) % radius);
            float x = Mathf.Sin(p / peroid * Mathf.PI * 2), y = Mathf.Cos(p / peroid * Mathf.PI * 2);
            return Perlin2DLayered(x * radius, y * radius + offset, layers);
        }

        public static float ReRange(float val, float curMin, float curMax, float newMin, float newMax)
        {
            val -= curMin;
            val /= curMax - curMin;
            val *= newMax - newMin;
            val += newMin;
            return val;
        }



        /*
	     * Distance from point to line, capped determines if the line is considered 
	     * infinite or a line segment
	     */
        static public Vector3 ClosestPointToLine(Vector3 l0, Vector3 l1, Vector3 point, bool capped)
        {
            Vector3 line = l1 - l0;
            Vector3 lineNorm = line.normalized;
            Vector3 relP = point - l0;

            float dist = Vector3.Dot(lineNorm, relP);

            if (capped)
            {
                dist = Mathf.Clamp(dist, 0, line.magnitude);
            }

            return l0 + lineNorm * dist;
        }



        public delegate float BoundingValueDelegate<T>(List<T> col, int index);
        
        /*
            Find the bounding pair of indicies from a collection

            Remember that delegates generate an object so if you call this often, cache the delegate for reuse
        */
        public static float FindBoundingValues<T>(List<T> col, float val, BoundingValueDelegate<T> del, ref int li, ref int ui)
        {
            li = 0;
            ui = 0;
            float lv = 0;
            float uv = 0;

            //before start
            if(val<= del(col, 0))
            {
                return 1;
            }

            for (; ui < col.Count-1;)
            {
                li = ui;
                ui++;
                lv = uv;

                var curval = del(col, ui); ;
                uv += curval;

                val -= curval;

                if (val <= 0)
                {
                    return (val - lv) / (uv - lv);
                }
            }

            //didn't bottom out return so it's beyond the end
            li = ui;
            return 1;
        }

        public static bool IsAnyMouseOrTouchOverCurrentEventSystemGameObject()
        {
            bool retval = false;

            retval |= EventSystem.current.IsPointerOverGameObject();

            for(int i = 0; i < Input.touchCount; i++)
            {
                retval |= EventSystem.current.IsPointerOverGameObject(Input.touches[i].fingerId);
            }

            return retval;
        }

        public static T FirstNonNull<T>(T[] tArr) where T : class 
        {
            for (int i = 0; i < tArr.Length; i++)
            {
                if (tArr[i] != null) return tArr[i];
            }

            return null;
        }

        //for certain unity objects this appears to be failing
        public static T FirstNonNull<T>(List<T> tArr) where T : class
        {
            for (int i = 0; i < tArr.Count; i++)
            {
                if (tArr[i] != null)
                {
                    return tArr[i];
                }
            }

            return null;
        }

        public static byte[] HexStringToByteArray(string hexString)
        {
            //two chars per byte
            byte[] res = new byte[hexString.Length / 2];

            for(int i = 0; i < res.Length; i++)
            {
                byte curByte = 0;
                byte.TryParse(hexString.Substring(i*2, 2), System.Globalization.NumberStyles.HexNumber, null, out curByte);
                res[i] = curByte;
            }

            return res;
        }

        //http://stackoverflow.com/questions/311165/how-do-you-convert-byte-array-to-hexadecimal-string-and-vice-versa/24343727#24343727
        private static readonly uint[] _lookup32 = CreateLookup32();

        private static uint[] CreateLookup32()
        {
            var result = new uint[256];
            for (int i = 0; i < 256; i++)
            {
                string s = i.ToString("X2");
                result[i] = ((uint)s[0]) + ((uint)s[1] << 16);
            }
            return result;
        }

        private static string ByteArrayToHexViaLookup32(byte[] bytes)
        {
            var lookup32 = _lookup32;
            var result = new char[bytes.Length * 2];
            for (int i = 0; i < bytes.Length; i++)
            {
                var val = lookup32[bytes[i]];
                result[2 * i] = (char)val;
                result[2 * i + 1] = (char)(val >> 16);
            }
            return new string(result);
        }

        public static string ByteArrayToHexString(byte[] arr)
        {
            return ByteArrayToHexViaLookup32(arr);
        }

        public static System.TimeSpan SinceEpoch()
        {
            System.TimeSpan span = System.DateTime.UtcNow.Subtract(new System.DateTime(1970, 1, 1, 0, 0, 0));
            return span;
        }

        public static float Remap(float val, float valMin, float valMax, float outterMin, float outterMax) 
        {
            val = RemapUnclamped(val, valMin, valMax, outterMin, outterMax);
            return Mathf.Clamp(val, outterMin, outterMax);
        }
        
        public static float RemapUnclamped(float val, float valMin, float valMax, float outterMin, float outterMax)
        {
            val -= valMin;
            val /= valMax - valMin;
            val *= outterMax - outterMin;
            val += outterMin;
            return val;
        }
        
        //only tested with orth camera
        public static Vector3 CalcPositionForCameraFromAnObjectsDesiredViewportPosition(Camera cam, Transform targetObject, Vector2 desiredViewportPos)
        {
            bool d3d = SystemInfo.graphicsDeviceVersion.IndexOf("Direct3D") > -1;
            Matrix4x4 M = cam.transform.localToWorldMatrix;
            Matrix4x4 V = cam.worldToCameraMatrix;
            Matrix4x4 p = cam.projectionMatrix;
            if (d3d)
            {
                // Invert Y for rendering to a render texture
                for (int i = 0; i < 4; i++)
                {
                    p[1, i] = -p[1, i];
                }
                // Scale and bias from OpenGL -> D3D depth range
                for (int i = 0; i < 4; i++)
                {
                    p[2, i] = p[2, i] * 0.5f + p[3, i] * 0.5f;
                }
            }
            Matrix4x4 MVP = p * V * M;

        
            Vector3 curViewSpacePos = cam.WorldToViewportPoint(targetObject.position);
            var viewDif = (Vector2)curViewSpacePos - desiredViewportPos;
            var t = (MVP.inverse * viewDif) * 2;
            return cam.transform.TransformPoint(t);
        }
    }
}